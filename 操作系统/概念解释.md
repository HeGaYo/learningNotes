## 操作系统
- **进程和线程的区别**
**四个方面**
**调度方面**：进程是操作系统资源分配和独立调度的单位；线程是操作系统独立调度的单位。同一个进程中，线程切换不会引起进程切换；在不同进程中，线程切换会引起进程切换。
**资源拥有**：一个进程可以由多个线程组成，这些线程可以访问所属进程的资源，并且拥有自己的线程ID,当前指令指针，寄存器集合和堆栈。
**并发性**：多进程可以并发，多线程也可以并发。
**系统开销**：进程在创建和撤销时，系统要为之分配和回收资源，操作系统开销比创建、撤销线程要大。线程切换的系统开销比进程切换的系统开销要小。并且线程之间的同步和通信比较容易实现，无需操作系统干预。
- **进程和程序的区别**
    1. 进程是一个动态的概念，是一个程序的一次活动；程序是一个静态的概念，是一组有序的静态指令。
    2. 一个进程可以执行多个程序，一个程序可以被多个进程执行
    3. 程序可以作为一个软件资源并长期保持着，而进程只是一次执行过程，是暂时的。
- **linux下进程通讯的方式**
**管道**：分为有名管道和无名管道，两个限制，半双工，亲缘关系进程间使用（无名管道）。速度慢，无名管道只有父子进程才可以通信；有名管道（FIFO）速度慢，任何进城之间可以通信
**信号**：仅用作通知进程中有某些事情发生
**信号量**：计数器，用来控制多个进程对于共享资源的访问；不传递任何信息，仅用作同步
**消息队列**：是有信息的链表，存放在内存中并由消息队列标识符标识；容量受系统控制，且第一次读的时候要考虑上一次没有读完的数据。
**共享内存**：映射一段能被其他进程访问的内存，由一个进程创建，多个进程访问。能够很容易控制容量，速度快，但是要保持同步，比如一个进程在读的时候，另一个进程要注意读写问题。
**套接字socket**：可用于不同主机的进程间通信
- **同步的方式有哪些**
**线程安全**：可访问的全局变量和堆数据随时会被其他线程改变，因此多线程并发的时候要注意保持数据的一致性。
**同步**：当一个线程访问数据未结束时，其他线程不得对同一个数据进行修改。如此，对数据的访问就被原子化了。
进程间同步的主要方法有原子操作、信号量机制、自旋锁、管程、会合、分布式系统等
- **用户级线程和内核支持的线程的区别**
用户级线程是受内核支持，无需内核管理
内核线程是由OS内核直接支持和管理
**区别**：
    1. **内核能否感知**： 内核线程是os内核可感知的，用户级线程是内核不可感知的。
    2. **创建、撤销和调度是否需要OS内核的支持**：用户线程在创建、撤销和调度都不需要OS内核的支持，是在语言级处理；而内核支持的线程创建、撤销和调度需要OS内核支持，与进程级别的创建、撤销和调度大体上是一样的。
    3. **执行系统调用时所属进程是否会被中断**： 用户线程执行系统调用执行时将导致其所属的进程被中断；而内核支持线程执行系统调用命令时，只会导致该线程被中断。
    4. **CPU调度的单位**：在只有用户级线程的系统中，CPU是以进程为调度单位，而有内核支持的线程的系统中，CPU调度是以线程为单位。
    5. **程序实体的运行状态**：用户级线程的程序实体是运行在用户态的程序，而内核支持线程的程序实体是可以运行在任何状态下的程序。

- **同步机制遵循的原则**
    空闲让进
    忙则等待
    有限等待
    让权等待
- **PV操作**：
    一个初始值为N的信号量允许N个线程并发访问。
    - 线程访问资源的时候先获得信号量：(**P操作**)
        信号量减1
        如果信号量>=0,进程继续执行
        如果信号量<0, 则进入等待状态
    - 访问完资源释放信号量（**V操作**）
        信号量加1
        如果信号量>0进程继续执行
        如果信号量<=0（说明有至少一个被挂起的队列）,则唤醒一个等待中的线程，使其变成就绪状态并插入就绪队列，然后返回原进程继续执行
- **进程死锁的条件**
**概念**：多个进程因为竞争资源而造成互相等待的情况。
**原因**：资源有限，多个进程的推进顺序不合理
**四个必要条件**：
互斥——一次只能有一个进程使用这个资源
请求并等待——一个进程占有至少一个资源，并且等待另一个资源，而该资源被其他资源占用
非抢占式——资源不能被强占，要等到任务完成之后才会释放
循环等待——p1等待p2,p2等待p3，p3等待p1
**预防死锁**：只需要破坏任意一个必要条件即可
    1. 鸵鸟算法：因为死锁发生的概率比较低，不做处理，但这是一种消极的做法
    2. 检测并预防：共享资源不要求互斥条件；当进程申请资源时，它不能占有其他资源；资源可被强占；将资源有序的分配，避免循环等待的“环路”发送。

- **CPU调度的算法**
FCFS（先来先服务）
SJST(最短作业优先， 抢占式、非抢占式)
PRIORITY SCHEDUE（优先级调度）
RR （时间片轮询调度）

- **虚拟内存，页置换算法**
FIFO，先来先置换
OPR，最优置换，往后看，置换最长时间未被使用的页
LRU，least-recently-used，往前看，置换最近最少使用的页

- **系统颠簸**
**是什么**：频繁的页调度
**原因**：操作系统会监控CPU使用率，使用率过低就会向系统引入新的进程，增加多道程序的程度。采用全局置换算法，置换的时候不管页是属于哪个进程。新进来一个进程，由于帧数不够，开始出现页面错误，然后需要用调页设备来换入换出页。随着进程排队等待调页设备，就绪队列变空，cpu使用率降低，cpu调度器发现cpu使用率较低，就会继续引入新的进程，增加多道程序的程度，恶性循环，产生更多的页面错误。
**解决方案**
对页面调度算法添加预取页（要看增加页面的成本是否小于处理相应页面错误的成本）
增加页面大小（随机访问数据、顺序访问数据）

- **磁盘调度算法**
FCFS
SSTF(最短寻道时间优先算法)
SCAN（电梯算法，先到0，再慢慢增加）
C-SCAN（先慢慢增加到最大值，然后立即到0，再慢慢增加）
LOOK（先到最小值，再慢慢增加）
C-LOOK（先慢慢增长到最大值，然后立即跳到最小值，再慢慢增加）
- **文件系统实现，外存分配的算法**
连续分配
链式分配
索引分配

- **时间花费**
寻道时间:磁头定位到磁道
旋转延迟：到达扇区开始的位置
传输时间：传送数据所需的时间

- **内存管理**
物理地址：内存单元所能看到的地址
逻辑地址：cpu生成的地址
外部碎片：尽管所有的内存空间加起来能够满足一个请求，但这些空间是不连续的
内部碎片：内存以固定大小的块为单位来分配，分配的内存比所要的要大，他们之间的差称为内部碎片

- **连续内存分配方式采用的几种算法**
**首次适应算法**：缺点在于低址部分不断被划分，留下许多难以利用、非常小的空闲区，而每次查找又都从低址部分开始，这无疑会增加查找的开销。
**循环首次适应算法**：从上次找到的空闲分区开始查找，直至找到一个能满足需求的空闲分区，并从中划出一块来分给作业。缺点是将会缺乏大的空闲分区。
**最佳适应算法**：既能满足需求，又是最小的空闲分区分配给作业
**最差适应算法**：缺点是保留大的空闲区的可能性减小了，而且空闲区回收也和最佳适应算法相同复杂。

- **分段和分页**
**分段**：把一段与程序所需要的内存空间大小的虚拟空间映射到某个地址空间；按照段名（用户视角）来分，段号+偏移量。
优点：地址隔离（程序A和程序B被映射到两块不同的物理区域）；每个程序被分配到物理地址的哪个区域对程序来说是透明的
缺点：内存使用效率问题，分段对于内存区域的映射是以程序为单位，如果内存不足，被换入换出到磁盘的是整个程序，会造成大量的磁盘访问操作，从而影响速度
**分页**：把地址空间人为地分成固定大小的页，每一页的大小由硬件决定。将主存分为同样大小的小块，将进程中的块（逻辑内存：页）指向内存中的块（物理内存：帧）。
**段页式存储管理方式**
 　　基本原理是分段和分页相结合，其地址结构由：段号、段内页号、页内地址三部分组成。在段页式系统中获得一条指令需要三次访问内存，第一次访问内存中的段表，第二次访问内存中的页表，第三次访问内存中的数据。
*TLB转换表缓冲区*
**区别**：
    1. **页是信息的物理单位**，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率；或者说，分页仅仅是由于系统管理的需要，而不是用户的需要。
    2. **段是信息的逻辑单位**，它含有一组其意义相对完整的信息。分段的目的是为了能 更好的满足用户的需要。
    3. **页的大小固定且由系统确定**，把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而一个系统只能有一种大小的页面。**段的长度却不固定**，决定于用户所编写的程序，通常由编辑程序在对源程序进行编辑时，根据信息的性质来划分。
    4. **分页的作业地址空间是一维的**，即单一的线性空间，程序员只须利用一个记忆符，即可表示一地址。**分段的作业地址空间是二维的**，程序员在标识一个地址时，既需给出段名，又需给出段内地址。

- **常见的linux文件系统**
ext2, ext3, ext4

- **Linux 基本操作**
1. 如何在 Linux 系统下查看 CPU、内存、磁盘、IO、网卡情况？
cpu  top 看进程和cpu的使用率  
uptime 看cpu负载
内存 free 看内存呢虚拟内存 -m 是以兆为单位显示
硬盘 df -hT 查看个各个分区的使用情况，-h是以G为单位显示  -T是显示分区的系统类型
iostat -x 1 可以查看磁盘的IO信息
2. 如何查看一个进程的详细信息，如何追踪一个进程的执行过程
3. awk、sed 等文件处理工具的使用
4. 熟练使用一种 Linux 下的编辑器（VIM、Emacs）

- **动态链接及静态链接**
**静态链接** 就是在编译链接时直接将需要的执行代码拷贝到调用处，优点就是在程序发布的时候就不需要的依赖库，也就是不再需要带着库一块发布，程序可以独立执行，但是体积可能会相对大一些。
**动态链接** 就是在编译的时候不直接拷贝可执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定的代码时，去共享执行内存中已经加载的动态库可执行代码，最终达到运行时连接的目的。优点是多个程序可以共享同一段代码，而不需要在磁盘上存储多个拷贝，缺点是由于是运行时加载，可能会影响程序的前期执行性能。
**动态链接库的两种链接方法**：
(1) **装载时动态链接**(Load-time Dynamic Linking)：这种用法的前提是在编译之前已经明确知道要调用DLL中的哪几个函数，编译时在目标文件中只保留必要的链接信息，而不含DLL函数的代码；当程序执行时，调用函数的时候利用链接信息加载DLL函数代码并在内存中将其链接入调用程序的执行空间中(全部函数加载进内存），其主要目的是便于代码共享。（动态加载程序，处在加载阶段，主要为了共享代码，共享代码内存）
(2) **运行时动态链接**(Run-time Dynamic Linking)：这种方式是指在编译之前并不知道将会调用哪些DLL函数，完全是在运行过程中根据需要决定应调用哪个函数，将其加载到内存中（只加载调用的函数进内存），并标识内存地址，其他程序也可以使用该程序，并用LoadLibrary和GetProcAddress动态获得DLL函数的入口地址。（dll在内存中只存在一份，处在运行阶段）
上述的区别主要在于阶段不同，编译器是否知道进程要调用的dll函数。动态加载在编译时知道所调用的函数，而在运行态时则必须不知道。

- **DMA**
直接内存存取
DMA是指外部设备不通过CPU而直接与系统内存交换数据的接口技术。

- **中断** 　
程序中断通常简称中断，是指CPU在正常运行程序的过程中，由于预先安排或发生了各种随机的内部或外部事件，使CPU中断正在运行的程序，而转到为响应的服务程序去处理。
轮询——效率低，等待时间很长，CPU利用率不高。
中断——容易遗漏一些问题，CPU利用率高。
- **临界区**
每个进程中访问临界资源的那段程序称为临界区，
