项目中遇到过的问题。
总之要把写在简历上的项目部分熟悉一遍，技术栈、项目功能、难点都要考虑好
## 研究方向
云计算方向，具体为云操作系统openstack、docker技术以及分布式系统自动化部署系统的开发设计
## 分布式云系统的自动部署技术研究
- 讲述下你的项目
    - 我们的项目是对分布式云系统进行自动化部署。这里所说的分布式云系统是有一个中央管理节点和若干个落地云集群构成的一个系统。我们主要是对靠近用户的落地云集群的云环境进行自动部署。我们通过一系列的web页面引导用户填写配置信息，然后对于几台服务器进行自动化部署。部署的内容包括操作系统的重装、云操作系统的自动安装。
    - 为了更加具体的描述我的项目，我可以用一个简单的例子来讲述，结合一些实现的细节。比如说现在我们已经部署好了一个云集群，需要对他进行扩容，简单来说就是添加一台物理主机，我们的系统就能够完成自动扩容的过程。
        -   首先是主机发现，就是让远程主机主动向部署节点汇报自己的ip地址、mac地址和硬件信息，这些信息都有助于后续的安装操作。
        - 然后是系统配置，用户可以选择操作系统的版本，填写一些配置信息，包括操作系统登录的账号密码、网络的配置（设置网段、配置网卡）。这些信息会生成一个模板文件(preseed文件，自动应答文件)，用于操作系统的自动安装。
        - 紧接着是云节点的配置，我们要选择这个服务器在云集群担任的角色，比如计算节点、网络结点还是存储节点，然后配置他的管理网络、外部网络和内部网络。
        - 最终我们利用ansible和docker技术，将openstack的组件封装成一个个容器，服务器安装完软件配置之后会主动拉取部署节点容器仓库中对应的容器镜像，然后在本机启动对应组件的容器，并提供相应的云服务。
    - 在这个项目里具体用到的技术包括微型镜像开发、网络安装、容器技术、ansible远程运维、web-ssh等等。
- 你负责的部分
我从一开始就负责这个项目。因此参与了前期的技术调研，比如说各个自动化部署工具的对比，各种不同方案的选择，以及后续的技术方案确定，对于项目的需求进行明确的定义，以及整个项目的实施流程设计，并且还进行了数据库设计、功能设计等前期工作。在后期的项目开发中，主要负责的是远程运维和容器部署云操作系统openstack这部分的代码开发工作。
- 云计算是什么
    - 随着计算、存储和处理能力需求的提高，传统的it架构已经远远不能满足要求。因此为了节省成本和提高系统的可拓展性，云计算应运而生。
    云计算是一个很泛的概念，在我看来，云计算其实是通过互联网访问的一些服务。最直观的就是用户需要用到计算能力或者处理能力，但是因为资金或者条件的限制，不能构建这么一个云集群，那么就可以尝试云计算服务这种方式，通过互联网付费按需地去使用运营商提供的云服务。
    - 一般我们按服务类型来分类的话，分为三种，分别是iaas、paas和saas。
        - iaas，基础设施即服务，其实是由互联网提供的基础的计算资源，包括处理能力、存储空间、网络等等。用户可以申请硬件或虚拟硬件，包括裸机、虚拟机，然后再在上面安装自己想要的操作系统或者其他应用程序。
        - paas，平台及服务，将计算环境和开发环境等平台作为一种服务通过互联网提供给用户，一般来说用户会申请到一个已经安装好操作系统以及能够支持应用程序运行所需的运行库等软件的虚拟机或者物理机，然后再在上面安装其他应用程序。但是呢，这时候用户是不能去修改已经预装好的操作系统和运行环境。
        - saas，软件及服务，通过互联网，向用户提供软件及应用程序的一种服务方式，应用程序安装仔厂商或者服务提供商那里，用户可以通过租赁的方式来使用这些软件，而不是购买，直观来说，用户可能获得到了一组用户名或者密码。
- 云计算的一些特点
    - 高可靠性 (多副本容错、计算节点同构等措施保障服务可靠性)
    - 实时在线 (服务是通过互联网来提供的，随时随地)
    - 通用性 (可以支持多种应用，使用范围广)
    - 超大规模的计算能力 (跟服务器相关)
    - 按需服务 (根据用户的需求提供想要的服务)
- 云计算的一些发展
    - 云计算与大数据技术(大数据根植于云计算，云计算的关键技术中海量数据存储，海量数据管理技术和map reduce编程模型等都是大数据的基础)
    - 云计算与机器学习(提升性能，提供强大的计算能力)
    - 云计算与物联网(通过传感器，把任何物品与互联网相连，实现识别、定位、跟踪、监控等。智能融合，构建智慧地球)
    - 云计算与移动互联网(将计算从终端转到云端，只需要互联网就能实时在线访问服务，不再受限于终端的计算能力)
- 分布式云系统
我们需要部署的分布式云系统是由一个中央管理节点和若干个落地云集群构成。中央管理节点与各个落地云集群相连接。这样的一个架构分离了数据面、控制面和服务面，为分布式部署建云提供良好的体系。
    - 中央管理节点为整个系统的管理中心和资源中心，集中管理整个云的各种资源，包括镜像资源、应用资源、数据资源等。它可以收集不同落地云集群的资源信息、节点信息以及配置信息，并且将自动配置部署的命令推送到落地云集群的部署节点上。
    - 落地云集群是部署在用户区域的小型数据中心，包含了多个节点，比如部署节点、计算节点、网络结点和存储节点等。管理云集群的云资源并提供云服务，执行来自中央管理节点的命令。

- openstack是什么
    - openstack是对数据中心的计算、存储和网络资源进行统一管理，它针对的是IT基础设施，是iaas这个层次的云操作系统。
    - openstack是iaas层的一个软件系统，包含多个服务和应用程序，这些服务和应用程序被部署到不同的主机上，这些物理主机通过网络相连，形成一个大的分布式系统。iaas层系统就是要解决如何自动管理由这些物理主机虚拟出来的虚拟机，包括虚拟机的创建、迁移、关闭、虚拟存储的创建和维护，虚拟网络的管理，还包括监控计费，高可用性，安全等等。
    - 管理三种类型的IT资源：计算（）、存储、网络，通过云计算平台，这三个资源成为了三个池子，当需要虚拟机时，根据虚拟机请求的规格，平台快速从这三个资源池分配相应的资源，部署一台虚拟机，虚拟机使用者不需要去关心运行在哪里，存储空间从哪里来，ip是怎么分配等待。云平台把这些都搞定了。

- openstack各个组件的介绍(创建虚拟机的过程，串起来)
openstack提供了一个web界面，用户可以进行操作，这里用到的是horizon组件。我们现在要创建一台虚拟机，点击了创建虚拟机，并且填写了虚拟机的配置（包括操作系统选择、网络选择、安全组选择）然后会将这一请求交由openstack后端来完成。
nova组件负责虚拟机的一系列生命周期管理，要知道操作系统的类型同时下载镜像以供虚拟机启动，这部分工作由glance组件来执行，glance管理的镜像可能在swift组件上，需要与swift交互才能得到所需的镜像文件。
当然也需要cinder提供块存储的服务，需要neutron组件提供网络服务，使得虚拟机能够有volume可用，并且被分配到ip地址与外界网络与其他虚拟机进行通信。而且，在这之后，虚拟机资源的访问由keystone组件认证之后才可以继续连接。至此，openstack所有的核心组件都参与到了创建虚拟机的这个操作中。
nova - 计算服务：虚拟机生命周期管理
neutron - 网络服务：虚拟网络的创建、管理和网络设备接口连接
glance - 镜像管理：镜像管理、存储
swift - 对象存储：存储检索对象
cinder - 块存储：块存储服务
keystone - 身份验证：身份验证，权限控制
horizon - 界面：基于django开发，可视化界面

- 分布式的概念
分布式分为3步：
将整个软件视为一个系统
然后将系统分割成一系列的进程，每个进程完成一部分的功能
在将这些进程分布到不同的主机上，通过若干种通信协议把他们连接起来
- 分布式与集群的区别
1. 分布式是指将不同的业务分布在不同的地方。 而集群指的是将几台服务器集中在一起，实现同一业务。
分布式中的每一个节点，都可以做集群。 而集群并不一定就是分布式的。
2. 分布式是以缩短单个任务的执行时间来提升效率的，而集群则是通过提高单位时间内执行的任务数来提升效率。
- 虚拟化是什么
虚拟化是云计算的基础，简单来说，虚拟化使得一台物理的服务器可以跑多台虚拟机，虚拟机共享物理机的cpu、内存、io硬件资源，但是在逻辑上各个虚拟机时分隔的。每个虚拟机有自己的虚拟硬件，并且提供独立的执行环境。
我们一般更关注于硬件层面上的虚拟化，将物理计算机虚拟化成多台虚拟机，然后通过网络将这些虚拟机互联互通，形成了我们所说的云计算系统。硬件抽象层的虚拟化是指通过虚拟硬件抽象层来实现虚拟机，为客户机操作系统呈现出与物理硬件相同或者相近的硬件抽象层。
有两种方式:
方式1：hardware-hypervisor-os，vmm直接运行在操作系统上并管理客户操作系统
方式2：hardware-os-hypervisor-os kvm,virtualbox，vmm运行在一个传统的操作系统上，可以看做是软件第二层客户机os在第三层。

- 举例：hypervisor的例子——kvm
kvm本身只管理虚拟机调度(cpu调度)和内存管理两个方面
io的虚拟化就交给linux内核和qemu
libvirt可以管理kvm，当然也可以管理virtualbox、xen等等。由后台daemon程序libvirtd、api库以及virsh命令行工具构成。
基于libvirt的高级工具：virt-manager，这个是一个图形化的工具，可以对kvm进行管理
virsh是管理kvm的命令行工具

- kvm虚拟化的原理：
    - cpu虚拟化：查看是否支持虚拟化
        ```
        egrep -o '(vmx|svm)' /proc/cpuinfo
        vmx//说明cpu支持kvm
        ```
        一个kvm的虚拟机其实是一个qemu-kvm进程，与其他linux进程一样被调度。
        虚拟机中的每一个虚拟vcpu对应这个qemu-kvm进程中的一个线程(虚拟机的vcpu的数量可以超过物理cpu的数量)
    - 内存虚拟化
        kvm通过内存虚拟化来共享物理系统内存，动态分配给虚拟机。为了在一台机器上运行多个虚拟机，kvm需要实现VA(虚拟内存)-PA(物理内存)-MA(机器内存)之间的地址转换。虚拟os控制虚拟地址到客户内存物理地址的映射，但是虚拟os不能直接访问实际机器的内存，因此由kvm来负责映射客户物理内存到实际机器内存。
    - 存储虚拟化
    kvm的存储虚拟化是通过存储池和卷来管理的
    storage pool是宿主机能够看到的一片存储空间，可以是多种类型。：例如文件目录类型、lvm类型等等
    volume是storage pool中划分出来的一块空间，宿主机将volume分配给虚拟机，在虚拟机中看volume就是一块硬盘。：就是目录下的文件
    - 网络虚拟化
    linux bridge和vlan
        - linux bridge
        应用场景：给虚拟机分配一个vnet0(vnet0是该虚拟网卡在宿主机中的设备名称，设备类型是TAP设备)，通过linux bridge br0将eth0与vnet0相连。
        原理：linux bridge是用来tcp/ip二层协议交换的设备，简单可以理解为一个二层交换机或者hub，多个网络设备可以连接到同一个linux bridge，当某个设备收到数据包时，linux bridge可以将数据转发给其他设备。
        - vlan
        virtual local area net 虚拟本地局域网，一个带vlan功能的switch会将自己的端口划分成多个LAN，每个lan代表一个广播域。一个广播包会被lan中的所有计算机收到。其实vlan是将一个交换机分成了多个交换机，限制了广播的范围，在二层上将计算机隔离到不同的广播域中。二层上的隔离指的是tcp/udp的包，但是在三层上还是可以互通。
        trunk口：允许所有vlan id的数据通过，并且带上自己的vlan id
        access 口：端口被打上vlan的标签，直接与计算机网卡相连
        vlan设备总是以母子关系出现，母子设备之间是一对多的关系 eth0对应eth0.10, eth0.20等等。
        eth0可以看成是trunk口，eth0.10,vnet0,brvlan10可以看成是vlan10的access口
        eth0可以看成是trunk口，eth0.20,vnet0,brvlan20可以看成是vlan20的access口
        - 总结
        linux bridge(交换)+vlan(隔离)在功能层面上完整模拟现实世界中的二层交换机

- 容器是什么
把docker比喻成集装箱，负责运送软件
容器是直接运行在操作系统内核上的用户空间，容器技术可以让多个独立的用户空间运行在同一个宿主机上。
容器被认为是不安全的，因为它客居在宿主机上
得益于linux内核的cgroup与namespace技术，使得容器与宿主机之间的隔离更加彻底。容器有自己独立的网络和存储栈。还拥有自己管理资源的能力，使得同一台主机上的多个容器可以独立友好地共存。
docker就是能够将应用程序自动部署到容器的开源引擎。
docker客户端和服务器：c/s架构，客户端将请求发送到docker服务端或者守护进程，然后服务端/守护进程完成所有工作并返回结果。
docker镜像：镜像是基于联合(union)文件系统的一种层式的结构，由一系列的指令一步步构建。这些指令会卸载dockerfile里面。
registry ：分两种，公有的docker hub与私有的registry
docker容器：容器是基于镜像启动起来，一个容器里可以运行一个或者多个进程
- docker的底层实现原理
cgroup(资源限额)：control group控制分配的资源, linux操作系统通过cgroup设置进程使用CPU、内存和IO资源的限额。
namespace(资源隔离)：以彼此隔离的命名空间运行，用命名空间作为权限的隔离控制。每个容器中我们都可以查看文件系统、网卡等资源，这些资源就像是容器自己的一样。实现这种方式的技术是namespace，它管理着host中全局唯一的资源，并可以让每个容器都认为自己是唯一使用者。namespace能够实现资源的隔离。
一共有6种namespace，对应6种资源——mount namespace、UTS namespace、IPC namespace、PID namespace、network namespace、user namespace
- docker存储
docker为容器提供了两种存放数据的资源
由storage driver管理的镜像层和容器层：容器是由一个容器层和若干个镜像层组成，容器的数据是存放在这些层中，最大的特点是copy on write。修改的数据直接存放在最上面的容器层，修改现有的数据会先从镜像层复制到容器层，修改后的数据直接保存在容器层，镜像层不改变，如果多层中有命名相同的文件，用户只会看到最上层的文件
data volume(可进行数据共享)：bind mount(将host上已存在的目录或文件mount到容器里)和docker managed volume(不用指定mount源)
datavolume本质上是host文件系统中的目录或者文件，能够直接mount到容器的文件系统中，容器可以读写volume中的数据，volume数据可以被永久地保存，即使容器被销毁
- docker进行网络、cpu资源、存储资源虚拟化
操作系统级虚拟化。内核通过创建多个虚拟的操作系统实例（内核和库）来隔离不同的进程。
- 容器编排是否了解 为什么选择ansible
项目需求
- 容器与虚拟机的区别
首先明确一点，容器不是虚拟机，虚拟机时一种模拟系统，就是说在软件层面上通过模拟硬件的输入、输出，让虚拟机的操作系统得以运行在没有物理硬件支持的环境中。他的隔离性比较强。
基础设施 -> 虚拟机管理系统hypervisor -> 客户机os -> 各种软件依赖-应用
而容器呢，容器是基于镜像创建的，守护进程/docker服务端取代了hypervisor层，它是运行在操作系统上的后台进程，负责管理docker容器。守护进程直接与操作系统通信，为各个容器分配资源，将容器与操作系统进行隔离
容器的优势：容器小巧，启动比较快，迁移部署快，运行高效，可以节省大量的磁盘空间和其他系统资源。更擅长隔离不同的应用。
虚拟机的优势：更擅长隔离不同的运行环境。
基础设施-> 主操作系统 -> 各种依赖（打包在容器镜像里） -> 应用
- docker的特点
打包对象是任何软件及其依赖
硬件依赖：容器无需修改便可运行在几乎所有的平台上-虚拟机、物理机、公有云、私有云
隔离性：资源、网络和库都是隔离的，不会出现依赖问题
自动化：听过run/start/stop等标准化操作，非常适合自动化
高效性：轻量级，能够快速启动和迁移
职责分工：开发人员考虑怎么写代码，运维人员考虑怎么配置基础环境

- 项目的难点是什么
远程运维部分，用容器来部署openstack部分，流程设计部分

- 说一下微型镜像
首先通过 PXE 下载 microkernel ，然后直接在内存中执行，启动网卡，运行 agent 并向服务器汇报信息，并接收来自服务器的命令。基本的技术原理都是 PXE + linux initramfs ，根据不同的需要向 initramfs 中加硬件驱动。
debootstrap + busybox 工具
整个小系统在不安装额外的软件和内核模块的情况下，为 100 M 左右，并可加入 busybox 后裁减到 40-50 M（包含完整的基础库）
使用 busybox 替换基本命令并裁减
一个简化版的ubuntu系统，我们删除了一些不必要的软件、文件(busybox)，最终得到一个大约为60MB大小的操作系统，安装的时间大约为一分钟。

- linux启动过程
BIOS自检-->从BIOS中读取启动顺序-->读取MBR中的bootloader-->加载内核-->读取伪根-->读取根文件中的init

- 用到了哪些网络协议
dhcp获取ip地址 动态分配IP地址（dhcp-discover, dhcp-offer, dhcp-request, dhcp-ack）
xmlrpc协议 其实就是http协议，发送硬件信息到部署节点。xml词汇表作为消息有效负载，用于两台主机之间的通信
tftp协议：TFTP（Trivial File Transfer Protocol,简单文件传输协议）是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为69。简单，占用资源小，适合传递小文件。基于udp实现的。
ssh协议：是一种网络协议，用于计算机之间的加密登录。
用户发送登录请求-远程主机发送公钥-用户用公钥加密登录密码并发送-远程主机用私钥解密并判断密码是否正确，回复用户
攻击：中间人攻击，假扮远程主机发送公钥，然后欺骗用户发送密码，再去登录远程主机。预防措施是口令登录，首次登录的时候提示公户只知道公钥指纹，是否继续连接。然后如果链接的话会存储到known_hosts中。
- 远程运维的过程、设计的技术 - web-ssh 介绍 原理
web-ssh，我用到了一个开源的工具gateone。它是一个开源的项目，利用html5开发的终端模拟器，相当于一个ssh客户端。我的工作就是将它嵌入到web应用中，让我们能够在网页上点击一个链接就能远程通过ssh连接到远程主机。
解决的问题：1. 公钥的注入（在填写操作系统配置信息的时候将公钥写入，生成preseed文件时将公钥写入客户机对应的文件中.ssh/authorized_key）2. 配置gateone服务器，gateone这个开源项目里还是有一些bug的，需要自己去修改，然后要将这个js文件放入到web应用中，然后用div组件来引入这个控件 3. 动态修改我们点击的链接，传入客户机的ip地址组成新的url，传入到gateone服务器上。4. 实现一个免密码的登录。将id_rsa放入到default_ids中
- 为什么选用容器来部署
1. 减少人工操作，解决人工部署易出错，上线时间长，后期运维人员工作量比较大，技术门槛高
2. 版本可以升级回退，只需要停止旧的容器，运行新的容器
3. 集群扩容的时间大大缩短，docker秒级启动
4. 通过编排，提高openstack的耦合度
5. 隔离不同的应用，开销比虚拟机小

- flask-web框架
用python写的轻量级web应用框架。一个强健的核心，通过拓展的方式加入其他组件
- cobbler 自动装机， 用到的原理
用于快速建立网络安装环境，继承了PXE,DHCP,DNS,KISKSTART服务管理和yum仓库管理工具，可以上传镜像，注册system，各个组件包括distro,profile,system,repository,image等待。

- 网络启动 pxe启动
工作于c/s的网络模式，允许工作站通过网络从远端服务器下载映像，并由此通过网络启动操作系统，在启动过程中要求服务端分配IP地址，再用tftp协议下载一个启动软件包到本机内存中执行，由这个软件启动包完成客户机的基本软件设置，从而引导预先安装仔服务器的终端操作系统。

## 跨领域情感文本分类
- 项目简述
- 什么是跨领域文本情感分类
- 原理(映射关系)
- 预处理
- 输入
- 训练
- 输出
- 优化算法
- 词共现筛选词
- svd降维
- k-means聚类
- 神经网络
- 如何进行特征提取
- 如何分词
- 数据集
- 基本的一些机器学习算法要知道：决策树算法、贝叶斯网络

## 云晫实习
- 负责的工作
- 遇到的难点
- 身份认证功能模块
做什么的
发送了一个什么东西过去那个接口？？？
- 数据同步模块
做什么的
如何实现同步 celery后台任务

- 实习的收获

## 华为实习
- 实习的工作是什么
那个app做什么的哦 我突然忘记了

- OWS
- 实习的最大收获

## 建议
了解这些概念：
- 微服务
微服务可以理解为细粒度的SOA（面向服务的架构），在这样的一个架构里，每一个小的服务开发成单一应用的形式，运行在单一的进程中，并且使用http这样轻量级的API；服务能够满足使用者的需求，并且可以用自动化部署工具进行独立发布。
微服务被封装成轻量级、可移植、自给自足的容器，这些容器可以使用标准操作来处理，并可以在几乎任何硬件平台上一致运行。
- devops
- oss
- ows

## linux基本操作
