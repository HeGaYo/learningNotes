- 多线程通信的方式，系统产生死锁的原因（四个必要条件）？
循环等待
非抢占式
互斥
请求和保持
死锁预防：打破四个条件
死锁避免：银行家算法

线程和进程的联系和区别
    **四个方面**
    **调度方面**：进程是操作系统资源分配和独立调度的单位；线程是操作系统独立调度的单位。同一个进程中，线程切换不会引起进程切换；在不同进程中，线程切换会引起进程切换。
    **资源拥有**：一个进程可以由多个线程组成，这些线程可以访问所属进程的资源，并且拥有自己的线程ID,当前指令指针，寄存器集合和堆栈。
    **并发性**：多进程可以并发，多线程也可以并发。
    **系统开销**：进程在创建和撤销时，系统要为之分配和回收资源，操作系统开销比创建、撤销线程要大。线程切换的系统开销比进程切换的系统开销要小。并且线程之间的同步和通信比较容易实现，无需操作系统干预。
- linux进程通信ipc
![](assets/markdown-img-paste-20180728170219183.png)
- linux系统的进程怎么查看，怎么看进程占用的系统资源，怎么用命令给一个文件里面的数字按次数排序


- 进程通信的方式，僵尸进程 孤儿进程
- 说说怎么实现管道，为什么管道都是用于父子进程或兄弟进程（fork机制的原因），我说了子进程完全继承了父进程的内容，又问我信号会继承吗，我说是的，他说真的吗，难道有什么问题吗

- Linux内存管理
- Linux父进程怎么知道子进程结束了
- 进程状态有哪几个
- 守护进程创建
- 怎么查看进程
- 进程和线程区别
- 进程间通信方式
- 生产者消费者的类怎么实现？
- Linux启动过程
- 有个变量i=5,两个线程执行i++5次，i的结果是多少。
- 进程中断
- 进程饥饿

说一下虚拟地址是怎么映射到物理地址的，说一下这个过程

虚拟内存分页了解不？
4、进程和线程区别

- linux下进程间通信的几种主要手段简介：
1：管道（Pipe）及有名管道（named pipe）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；
2：信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）；
3：报文（Message）队列（消息队列）：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。
4：共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。
5：信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。
6：套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。
http内容。get() 和 post()方法的区别
如何在linux目录下找到最大的三个文件

什么情况下会发生死锁，解决策略有哪些？

作者：重口味  ぅヾ
链接：https://www.nowcoder.com/discuss/61958?type=2&order=0&pos=15&page=29
来源：牛客网

内存的页面置换算法
进程调度算法
进程间通信方式
进程线程区别
进程之间的通信
父子进程、孤儿进程
fork进程时的操作， 
这个部分我回答的都不好，只能是死记硬背，建议基础好的同学多看看操作系统这部分，能大大加分。

作者：叫小丁不叫小丁丁
链接：https://www.nowcoder.com/discuss/77507?type=2&order=0&pos=62&page=3
来源：牛客网

僵尸进程

Q：介绍一下僵尸进程吧

A：僵尸进程就是死掉之后还没有被父进程wait的进程，它们在运行结束之后PCB这些资源还没有被释放，等待父进程wait它们获得它们的状态。如果父进程不wait的话，僵尸进程多了，未被释放的资源就很多，这个时候系统性能就会受到影响。如果父进程早死了的话，子进程就会被托管到pid为1的进程，以前是init现在是systemd好像，它会定时wait掉所有死了的子进程

Q：怎样避免僵尸进程呢

A：单独一个线程wait子进程，或者emmm...有两个信号，一个SIGCHLD、一个SIGCLD，设置这两个信号的处理方式为忽略，它们告诉内核，不关心子进程结束的状态所以当子进程终止的时候直接释放所有资源就行。它们的区别是SIGCLD在安装完信号处理函数的时候还会检查是否已经存在结束的子进程，如果有就调用信号处理函数，而SIGCHLD不会，也就是可能会丢掉已经有子进程已经结束这个事实


用户态和内核态切换过程

进程间通信有哪些（有名管道，无名管道、共享内存、信号、信号量、消息队列、socket等），两台计算机间通信有哪些，对应的系统API接口、原理

内存的页面置换算法
进程调度算法
进程间通信方式
进程线程区别
进程之间的通信
父子进程、孤儿进程
fork进程时的操作，
这个部分我回答的都不好，只能是死记硬背，建议基础好的同学多看看操作系统这部分，能大大加分。
