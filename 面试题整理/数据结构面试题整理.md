冒泡排序，找下纸笔手写代码
讲述下不同排序算法的优缺点（时间复杂度、稳定性、海量数据排序）
栈的原理和应用：左右括号是否正确匹配的经典问题
简述下堆排序的原理？
topk的算法，之前有准备过，就秒写了个堆排，顺便还写了个快排topk的算法（方便写测试用例）
大量数据不能同时载入内存，该如何解决
动态规划的定义，什么时候能用，正确性
动态规划 和 栈？

说了几种排序。冒泡，快排，桶排序，基数排序，插入排序，希尔排序。

考官专门问了一下希尔排序。我说了一下大概原理，和为什么是不稳定的。

https://blog.csdn.net/MoreWindows/article/category/859207

topk问题，10亿个数选最小的100个

写两个代码 字符串转double，最大连续子数组的和，判断链表有环

链表排序

5.动态规划原理以及和分治法区别
一、分治法与动态规划主要共同点：
1）二者都要求原问题具有最优子结构性质，都是将原问题分而治之，分解成若干个规模较小(小到很容易解决的程序)的子问题。然后将子问题的解合并，形成原问题的解。
二、分治法与动态规划实现方法：
① 分治法通常利用递归求解。
② 动态规划通常利用迭代法自底向上求解，但也能用具有记忆功能的递归法自顶向下求解。
三、分治法与动态规划主要区别：
① 分治法将分解后的子问题看成相互独立的。
② 动态规划将分解后的子问题理解为相互间有联系，有重叠部分。


6.二叉树深度求解
满二叉树 log2n+1

如果有4亿个数，你只有1G内存，你怎么判断某个数已经出现了

链表排序

递归的原理是啥？递归中遇到栈溢出怎么解决
递归的本质就是压栈入栈
事实上，函数调用的参数是通过栈空间来传递的，在调用过程中会占用线程的栈资源。而递归调用，只有走到最后的结束点后函数才能依次退出，而未到达最后的结束点之前，占用的栈空间一直没有释放，如果递归调用次数过多，就可能导致占用的栈资源超过线程的最大值，从而导致栈溢出，导致程序的异常退出。

编写一个函数指针

HashMap解决冲突的方法
链式法

设计题，给每个组分配不同的IP段，怎么设计一种结构使的快速得知IP是哪个组的（开始想直接NAT协议搞一搞每个IP一个组的。。面试官说场景不对是给每部分的IP分组。。想用Trie树，面试官让我再优化一下。。）

非递归完成二叉树的先序遍历（差点没写出来。。用的左神教的Morris遍历。。）

讲一下快速排序的思路？

作者：重口味  ぅヾ
链接：https://www.nowcoder.com/discuss/61958?type=2&order=0&pos=15&page=29
来源：牛客网

剑指OFFER的各个题目是最常见的，即使不是原题也是题目的变体，因为面试不像笔试，一般不会出特别困难的题目，所以剑指OFFER上小而精的题目就非常适合。建议手刷一遍。PHP的同学可以参考专栏剑指OFFER
二叉树相关（层次遍历、求深度、求两个节点距离、翻转二叉树、前中后序遍历）
链表相关（插入节点、链表逆置、使用链表进行大数字的加减，双向链表实现队列、寻找链表中的环）
堆（大量数据中寻找最大N个数字几乎每次都会问，还有堆在插入时进行的调整）
排序（八大排序，各自的时间复杂度、排序算法的稳定性。快排几乎每次都问）
二分查找（一般会深入，如寻找数组总和为K的两个数字）
两个栈实现队列。
图（深度广度优先遍历、单源最短路径、最小生成树）
动态规划问题。

红黑树性质

分治法和动态规划的区别
计算时间复杂度
二叉树和哈希表查找的时间复杂度

AVL树、B＋树、红黑树

Q：介绍一下平衡二叉树、B＋树、红黑树

A：平衡二叉树每个节点的两颗子树高度相差小于2，所以也叫高度平衡树。红黑树根据黑高来实现每个节点的左右两颗子树高度相差低于2倍，虽然红黑树的平衡性没有AVL树严格，但是研究好像表明红黑树性能更好而且这个平衡度已经足够了。B＋树的话不是很清楚，但是知道它在数据库里用的多，还有只有它的叶节点包含实际数据，其他节点只含有键


poll和epoll的区别
Q：poll和epoll了解吗
A：从内核源码来分析吧，诶不用介绍select吗...算了，其实select跟poll是差不多的，复用了很多代码，只是记录监听events的数据结构不一样...（先介绍了select，然后讲了一下与poll的区别）。epoll的话，在类unix系统中好像只有linux有，epoll把epoll实例创建、events增删改还有events轮询都分开了，这样的话epoll实例就可以被同一个进程中的所有线程共享。epoll跟poll一样，使用链表节点记录监听events，但是呢它有三个链表型结构（就绪链表、辅助链表、红黑树），首先想要监听的events的节点被放到红黑树里，这样可以加快events节点的访问。events就绪之后会被挂载到就绪链表里去，当epoll_wait从内核空间向用户空间写出就绪events的时候，会遍历就绪链表，同时这个时候可能还会发生新的就绪events，这个时候已就绪的events不再添加到就绪链表里去，而是使用辅助链表...

大数据去重，我说mapreduce和哈希。面试官想问bitmap

3）一致性哈希
用求模的方式将服务器映射到一个2^32的圆上
用同样的方式将存储数据的键值映射到同一个圆上
然后用顺时针查找节点的方式，找到第一个遇到的节点，并将数据存储到这个服务器上。
另外为了解决服务器的位置可能有偏移，也就是说可能不均匀分布，
可以采用虚拟节点，将虚拟节点均匀分布在圆上，每个虚拟节点对应着一个服务器，然后按照刚刚的方式做映射 存储数据-虚拟节点-服务器。查找的时候也一样。

4）STL容器
5）红黑树设置红黑节点的作用，插入时间复杂度
平衡二叉树吧。从根节点到叶节点的黑色节点的个数是一样的，保证子树的平衡性
红黑树的操作时间跟二叉查找树的时间复杂度是一样的，执行查找、插入、删除等操作的时间复杂度为O（logn）。

6）B树和B+树
B树和b+树都是多叉搜索树。b+树是b树的变形。
b树是平衡多路查找树，用于降低IO操作。可以有多个孩子，n个节点的B树的高度为O（logn），可以在O（logn）的复杂度内实现插入、删除等动态操作。
一个m阶的B树：
	每个节点最多有m个孩子
	除了叶节点和根节点，每个节点最少有ceil(m/2)个孩子
	根节点至少有两个孩子
	所有叶节点出现在同一层，并且叶节点不包含任何关键字的信息，表明查询失败
	每个非终端节点的关键字信息从左往右按顺序升序排列
B+树是应文件系统所需而产生的变形树，不同点在于
	有n个子树的节点有n个关键字
	每个叶节点包含了关键字的信息以及指向这些关键字记录的指针，并且叶节点本身按照关键字的大小自小而大的顺序链接
	所有非终端节点可以看成是索引成分，节点中仅含其子树跟及诶单中最大(最小)关键字，B树非终端节点也包含了所要查找的信息

b+树是b树的变形树，
b+树在每个叶节点上除了存放键的相关信息外，还存储了指向相邻叶节点的指针，使得叶节点之间有了联系，从而加快检索多个相邻叶节点的效率。
b+树的磁盘读写代价更低，因为内部节点并没有指向关键字具体信息的指针，所以内部节点比b树小，也就是说同一个盘块可以容纳更多的关键字，对于磁盘IO的读写次数就降低了。另外查询的效率更加稳定，每个关键字查找都要从根节点到叶节点，每个关键字查询的路径长度相同，效率相当。

剑指OFFER的各个题目是最常见的，即使不是原题也是题目的变体，因为面试不像笔试，一般不会出特别困难的题目，所以剑指OFFER上小而精的题目就非常适合。建议手刷一遍。PHP的同学可以参考专栏剑指OFFER
二叉树相关（层次遍历、求深度、求两个节点距离、翻转二叉树、前中后序遍历）
链表相关（插入节点、链表逆置、使用链表进行大数字的加减，双向链表实现队列、寻找链表中的环）
堆（大量数据中寻找最大N个数字几乎每次都会问，还有堆在插入时进行的调整）
排序（八大排序，各自的时间复杂度、排序算法的稳定性。快排几乎每次都问）
二分查找（一般会深入，如寻找数组总和为K的两个数字）
两个栈实现队列。
图（深度广度优先遍历、单源最短路径、最小生成树）
动态规划问题。

深入

红黑树性质

分治法和动态规划的区别
计算时间复杂度
二叉树和哈希表查找的时间复杂度
