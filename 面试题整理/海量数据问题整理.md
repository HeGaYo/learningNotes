1. 寻找top的那个值
分成三步走：
第一步：分而治之，首先通过hash方法将数据分为k个小文件
第二步：利用hash_map进行统计，找到每个小文件中出现频率最高的那个值，得到k个值
第三步：利用堆排序或者快排，将k个值进行排序，找到最大的那个值

2. 寻找top10
如果海量数据分布在100台电脑上，想办法高效地统计出这批次数据出现次数最多的top10
考虑两种情况：
- 情况1：如果同一个元素只出现在某台电脑上
    - 用hash_map来统计每台电脑上频率最高的top10
    - 然后利用堆排序将100台电脑上的top10组合进行比较，得到结果
- 情况2：如果同一个元素会重复出现在不同的电脑上
    - 遍历一遍所有的数据，并且进行散列取模，使得同一个元素只出现在某台电脑上
    - 蛮力求解，统计每一台电脑上的所有元素出现的次数，然后把同一元素在不同机器上的出现次数进行累加，最终从所有数据中找到top10

3. 寻找共同的URL
给定a和b两个文件，然后各存放50亿个URL。每个URL占用64个字节，内存限制为4GB，求出a和b文件的共同URL
步骤1：分而治之，遍历a文件用哈希(hash(URL)%1000),将所得值存入1000个文件里面，对b文件也做同样操作。
步骤2：求出1000对小文件里面相同的URL即可。

4. 外排序
在内存外面排序。因为处理的数据量很大而不能一次性装入内存，因此只能讲数据写入读写比较慢的外存储器(通常是硬盘)上。
先划分为多个子文件
子文件里面数据进行排序
多路归并排序，得到大文件。
4.1 位图法，时间复杂度为O(n)
计算要用的位数，并且将每一位置为0
通过读取文件里面的每个整数来建立集合，将整数对应的位置为1
检验每一位，如果该位为1，就输出对应的整数。
应用：电话号码统计，2.5亿个数去重(每个数分配2位，00表示不存在，01表示出现一次，10表示出现多次，11无意义)
4.2 归并算法
分而治之，时间复杂度为O(nlogn)
将大文件分成若干块，对每一块进行排序，最后完成整个过程的排序

5. 布隆过滤器
有一定的误判率，位图法的拓展，一个值可能对应于多个位，当且仅当这些位都为1时我们认为这个值存在。当多个值对应同一位时，我们认为只有第一次修改是奏效的。

6. trie树
字典树
根节点为空，二层子节点最多为26个，以后第i层节点为26^i
